searchState.loadedDescShard("subspace_farmer", 0, "<code>subspace-farmer</code> is both a library and an app for …\nSize of the LRU cache for peers.\nCluster version of the farmer\nDisk piece cache implementation\nAbstract farm API\nA container that caches pieces\nFarmer-specific piece getter\nNode client abstraction\nPlotter abstraction\nPrimary <code>Farm</code> implementation that deals with hardware …\nThread pool managing utilities for plotting purposes\nVarious utilities used by farmer or with farmer\nFarming cluster cache\nFarming cluster controller\nFarming cluster farmer\nNATS client\nFarming cluster plotter\nRequest cache details from cache\nAn identifier for a cluster cache, can be used for in …\nBroadcast with identification details by caches\nCluster cache implementation\nCache details\nCache ID\nCreate cache service for specified caches that will be …\nCache ID\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMax number of elements in this cache\nCreates new ID\nCreate new instance using information from previously …\nPiece Cache ID\nBroadcast sent by controllers requesting caches in cache …\nBroadcast sent by controllers requesting farmers to …\n<code>NodeClient</code> used in cluster environment that connects to …\nCluster piece getter\nThis module exposed implementation of caches maintenance.\nCreate controller service that handles things like …\nThis module exposed implementation of farms maintenance.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new instance\nCreate a new instance\nSubmit a block signature\nUtility function for maintaining caches by controller in a …\nNumber of farms in a cluster is currently limited to 2^16\nUtility function for maintaining farms by controller in a …\nCluster farm implementation\nFarm details\nRequest farm details from farmer\nAn identifier for a cluster farmer, can be used for in …\nBroadcast with cluster farmer id for identification\nFarm ID\nCluster farmer ID\nCreate farmer service for specified farms that will be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new cluster farmer ID\nCreate new instance using information from previously …\nRun and wait for background tasks to exit or return an …\nTotal number of sectors in the farm\nGeneric broadcast message.\nGeneric one-off notification\nGeneric request with associated response.\nGeneric stream request where response is streamed using …\nNATS client wrapper that can be used to interact with …\nPublish error\nResponse type that corresponds to this request\nResponse type that corresponds to this stream request.\nRequest subject with optional <code>*</code> in place of application …\nRequest subject with optional <code>*</code> in place of application …\nNotification subject with optional <code>*</code> in place of …\nBroadcast subject with optional <code>*</code> in place of application …\nStream request error\nWrapper around subscription that transforms stream of …\nSubscribe error\nSubscriber wrapper that decodes messages automatically and …\nApproximate max message size (a few more bytes will not …\nSend a broadcast message\nDeterministic message ID that is used for de-duplicating …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new client from existing NATS instance\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new instance by connecting to specified addresses\nMake notification without waiting for response\nMake request and wait for response\nResponds to requests from the given subject using the …\nMake request that expects stream response\nResponds to stream requests from the given subject using …\nSimple subscription that will produce decoded broadcasts, …\nSimple subscription that will produce decoded …\nCluster plotter\nAn ephemeral identifier for a plotter\nType alias used for event handlers\nPlotter ID\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates new ID\nCreate new instance\nSubscribe to plotting progress notifications\nCreate plotter service that will be processing incoming …\nCan’t preallocate cache file, probably not enough space …\nChecksum mismatch\nDedicated piece cache stored on one disk, is used both to …\nDisk piece cache open error\nI/O error occurred\nOffset outsize of range\nSize of a single piece cache element\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOpen cache, capacity is measured in elements of …\nMax offset\nProvided offset\nSector will expire at the next segment index and should be …\nAuditing\nAuditing details\nDecoded farming error\nSpecial decoded farming error\nSector expiration became known\nDownloaded sector pieces\nDownloading sector pieces\nEncoded sector pieces\nEncoding sector pieces\nPlotting failed\nSector expiration information updated\nSector already expired\nProving failed altogether\nFailed to retrieve farmer info\nFailed to subscribe to slot info notifications\nAbstract farm implementation\nErased error type\nAn identifier for a farm, can be used for in logs, thread …\nErrors that happen during farming\nVarious farming notifications\nFinished plotting\nType alias used for event handlers\nOpaque handler ID for event handlers, once dropped handler …\nI/O error occurred\nLow-level auditing error\nLow-level proving error\nResult of piece storing check\nPiece is not stored already, and can’t be added because …\nNon-fatal farming error\nAbstract piece cache implementation.\nAn identifier for a cache, can be used for in logs, thread …\nOffset wrapper for pieces in <code>PieceCache</code>\nAbstract piece reader implementation\nAbstract plot cache implementation.\nGetter for plotted sectors\nSector is being plotted\nProving\nProving details\nResult of the proving\nManaged to prove within time limit, but node rejected …\nDetails about sector expiration\nDetails about sector currently being plotted\nVarious sector updates\nSlot info notification stream ended\nStarting plotting of a sector\nProved successfully and accepted by the node\nProving took too long\nCache ID\nFarm ID\nCache might have a vacant slot to store this piece. Vacant …\nWriting sector\nWritten sector\nPiece is already stored in the cache.\nContents of this piece cache.\nConsumes <code>HandlerId</code> and prevents handler from being removed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet already plotted sectors\nID of this cache\nID of this farm\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this error is fatal and makes farm unusable\nCheck if a piece is already stored in this cache, or it …\nMax number of elements in this cache\nCreates new ID\nCreates new ID\nSubscribe to farming notifications\nSubscribe to sector updates\nSubscribe to new solution notification\nGet piece reader to read plotted pieces later\nWrapper for pieces plotted under multiple plots\nGet plotted sectors instance\nRead piece from cache at specified offset.\nRead piece from cache.\nRead piece from sector by offset, <code>None</code> means input …\nRead piece index from cache at specified offset.\nRead pieces from cache at specified offsets.\nWhether proving ended up being successful\nRun and wait for background threads to exit or return an …\nNumber of sectors that were audited\nString variant of the error, primarily for monitoring …\nAudit duration\nAudit duration\nNumber of sectors in this farm\nStore piece in cache if there is free space, and return …\nStore piece in cache at specified offset, replacing …\nLower-level error\nLower-level error\nSegment index at which sector expires\nWhether this is the last sector queued so far\nInformation about old plotted sector that was replaced\nInformation about plotted sector\nProgress so far in % (not including this sector)\nWhether sector is being replotted\nHow much time it took to plot a sector\nWrapper data structure for pieces plotted under multiple …\nAdd new farm with corresponding piece reader\nAdd new sector to collect plotted pieces\nCheck if piece is known and can be retrieved\nAdd all sectors of the farm\nAdd old sector from plotted pieces (happens on replotting)\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIterator over all unique piece indices plotted\nRead plotted piece from one of the farms.\nFarmer cache that aggregates different kinds of caches of …\nFarmer cache worker used to drive the farmer cache backend\nCollection of <code>FarmerCache</code> instances for load balancing\nFind piece in cache and return its retrieval details\nFind pieces in cache and return their retrieval details\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet piece from cache\nGet piece from cache\nGet pieces from cache.\nGet pieces from cache.\nReturns a filtered list of pieces that were found in …\nReturns a filtered list of pieces that were found in …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to store a piece in additional downloaded pieces, if …\nTry to store a piece in additional downloaded pieces, if …\nCreate new piece cache instance and corresponding worker.\nSubscribe to cache sync notifications\nInitialize replacement of backing caches\nRun the cache worker with provided piece getter.\nRetry policy for getting pieces from DSN cache\nFarmer-specific piece getter.\nWeak farmer piece getter, can be upgraded to …\nExponential backoff between retries\nDowngrade to <code>WeakFarmerPieceGetter</code> in order to break …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFast way to get piece using various caches\nSlow way to get piece using archival storage\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMax number of retries when trying to get piece from DSN …\nCreate new instance\nFarmer-specific validator for pieces retrieved from the …\nTry to upgrade to <code>FarmerPieceGetter</code> if there is at least …\nFarmer-specific validator for pieces retrieved from the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new instance\nAbstraction of the Node Client\nNode Client extension methods that are not necessary for …\nAcknowledge segment header.\nGet the cached segment headers for the given segment …\nNode client wrapper around another node client that caches …\nGet farmer app info\nGet up to <code>limit</code> most recent segment headers. If there is a …\nGet piece by index.\nNode client implementation that connects to node via RPC …\nGet segment headers for the segments\nSubmit a block signature\nSubmit a slot solution\nSubscribe to archived segment headers\nSubscribe to block signing request\nSubscribe to slot\nNode client wrapper around another node client that caches …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new instance\nGets segment headers for the given segment indices, …\nSubmit a block signature\nNode client implementation that connects to node via RPC …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new instance of <code>NodeClient</code>.\nSubmit a block signature\nDownloaded sector pieces\nDownloading sector pieces\nEncoded sector pieces\nEncoding sector pieces\nPlotting failed\nFinished plotting\nAbstract plotter implementation\nSector plotting progress\nCPU plotter\nReturns the argument unchanged.\nGPU plotter\nWhether plotter has free capacity to encode more sectors\nCalls <code>U::from(self)</code>.\nPlot one sector, sending sector plotting events via …\nPool plotter\nTry to plot one sector, sending sector plotting events via …\nError message\nInformation about plotted sector\nStream of all plotted sector bytes\nHow much time it took to plot a sector\nCPU plotter\nType alias used for event handlers\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMetrics for CPU plotter\nCreate new instance\nSubscribe to plotting progress notifications\nGPU plotter\nGPU-specific <code>RecordsEncoder</code> with extra APIs\nType alias used for event handlers\nGPU encoder type, typically related to GPU vendor\nCUDA GPU records encoder\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMetrics for GPU plotter\nCreate new instance.\nSubscribe to plotting progress notifications\nCUDA implementation of <code>GpuRecordsEncoder</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new instance\nPool plotter.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new instance\nScrub everything\nBackground downloading panicked\nErrors that happen in background tasks\nBackground task panicked\nOnly scrub cache\nCache can’t be opened\nCan’t preallocate metadata file, probably not enough …\nCan’t preallocate plot file, probably not enough space …\nFailed to open farm\nFailed to create thread pool\nFailed to decode metadata header\nFailed to decode metadata header\nFailed to determine file size\nFailed to retrieve farmer info\nFailed to get segment header\nFailed to open or create identity\nFailed to read bytes from file\nFailed to subscribe to archived segments\nFailed to write bytes from file\nFarm info can’t be opened\nFarm info file does not exist\nFarm is too large\nFarming error\nFarm was found and read successfully\nIdentity can’t be opened\nIdentity file does not exist\nPublic key in identity doesn’t match metadata\nAllocated space is not enough for one sector\nInvalid number pieces in sector\nI/O error occurred\nI/O error occurred\nFarm is likely already in use, make sure no other farmer …\nFarm is likely already in use, make sure no other farmer …\nLow-level plotting error\nName of the metadata file\nScrub just metadata\nMetadata can’t be opened\nMetadata file does not exist\nMetadata file too small\nMissing archived segment header\nFarm was not found\nName of the plot file\nPiece cache error\nScrub metadata and corresponding plot\nPlotting error\nErrors that happen during plotting\nIdentity public key doesn’t match public key in the disk …\nReward signing\nScrub target\nSingle disk farm abstraction is a container for everything …\nErrors happening when trying to create/open single disk …\nImportant information about the contents of the …\nExclusive lock for single disk farm info file, ensuring no …\nOptions used to open single disk farm\nErrors happening during scrubbing\nSummary of single disk farm for presentational purposes\nFailed to spawn task for blocking thread\nUnexpected metadata version\nUnexpected metadata version\nV0 of the info\nWrong chain (genesis hash)\nHow much space in bytes is allocated for this farm\nHow much space in bytes was allocated\nPercentage of allocated space dedicated for caching …\nCollect summary of single disk farm for presentational …\nWhether to create a farm if it doesn’t yet exist\nWrapper data structure for direct/unbuffered I/O\nPath to directory where farm is stored.\nDisable farm locking, for example if file system doesn’t …\nEffective on-disk allocation of the files related to the …\nErasure coding instance to use.\nInformation necessary for farmer application\nFarming-related utilities\nThread pool size used for farming (mostly for blocking …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenesis hash of the chain used for farm creation\nGlobal mutex that can restrict concurrency of …\nID of the farm\nID of this farm\nFarm identity\nInfo of this farm\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKzg instance to use.\nLoad <code>SingleDiskFarm</code> from path is supposed to be stored, …\nHow many pieces one sector is supposed to contain (max)\nHow many sectors a will be plotted concurrently per farm\nCreate new instance\nCreate new single disk farm instance\nRPC client connected to Subspace node\nSubscribe to farming notifications\nSubscribe to sector updates\nSubscribe to new solution notification\nCache implementation specific to single disk farm\nGet piece cache instance\nPiece reader for single disk farm\nGet piece reader to read plotted pieces later\nHow many pieces does one sector contain.\nPlot cache for single disk farm\nGet plot cache instance\nRead information about sectors plotted so far\nPlotter\nNotification for plotter to start, can be used to delay …\nPublic key of identity used for farm creation\nRead all sectors metadata\nMode to use for reading of sector record chunks instead\nPrometheus registry\nAddress where farming rewards should go\nRun and wait for background threads to exit or return an …\nCheck the farm for corruption and repair errors (caused by …\nStore <code>SingleDiskFarm</code> info to path, so it can be loaded …\nNumber of sectors in this farm\nTry to acquire exclusive lock on the single disk farm info …\nWipe everything that belongs to this single disk farm\nName of the task\nLower-level error\nLower-level error\nLower-level error\nSegment index that was missing\nAllocated space in sectors\nCurrent allocated space\nAllocated space\nHex-encoded genesis hash during farm creation\nPublic key used during farm creation\nFarm ID\nFarm ID\nFarm ID\nNumber of pieces in sector farm is initialized with\nMax supported allocated space in sectors\nMax supported allocated space\nMax supported pieces in sector\nMinimal allocated space\nHex-encoded current genesis hash\nCurrent public key\nHow much space in bytes is allocated for this farm\nGenesis hash of the chain used for farm creation\nID of the farm\nHow many pieces does one sector contain.\nPublic key of identity used for farm creation\nLow-level error\nLow-level error\nLow-level error\nLow-level error\nLow-level error\nLow-level error\nLow-level error\nAffected file\nAffected file\nAffected file\nInfo file\nInfo file\nIdentity file\nIdentity file\nMetadata file\nMetadata file\nMetadata file\nCache file\nIdentity public key\nDisk farm info public key\nOffset in the file\nOffset in the file\nReserved size\nNumber of bytes to read\nNumber of bytes to read\nFile size\nPath to directory where farm is stored.\nPath to directory where farm is stored.\nPath to directory where farm is stored.\nError itself\nFarm info\n4096 is as a relatively safe size due to sector size on …\nWrapper data structure for direct/unbuffered I/O\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOpen file at specified path for direct/unbuffered I/O for …\nTruncates or extends the underlying file, updating the …\nPlot auditing implementation\nPlot audit options\nAudit this plot\nErasure coding instance\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKzg instance\nCreate new instance\nPublic key of the farm\nFiles abstraction that allows reading concurrently using …\nMode of reading chunks during proving\nReward address to use for solutions\nOptional sector that is currently being modified (for …\nMetadata of all sectors plotted so far\nSlot info for the audit\nProof of space table generator\nWrapper data structure for multiple files to be used with …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOpen file at specified path as many times as there is …\nOpen file at specified path as many times as there is …\nDecoding error\n<code>Identity</code> struct is an abstraction of public &amp; secret key …\nErrors happening when trying to create/open single disk …\nInvalid contents\nI/O error occurred\nCreates new identity, overrides identity that might …\nReturns entropy used to generate keypair.\nSize of the identity file on disk\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOpens the existing identity, returns <code>Ok(None)</code> if it doesn…\nOpens the existing identity, or creates a new one.\nReturns the public key of the identity.\nReturns the secret key of the identity.\nSign reward hash.\nDedicated piece cache stored on one disk, is used both to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrapper data structure that can be used to read pieces …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead piece from sector by offset, <code>None</code> means input …\nChecksum mismatch\nAdditional piece cache that exploit part of the plot that …\nDisk plot cache open error\nI/O error occurred\nFailed to spawn task for blocking thread\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStore piece in cache if there is free space, and return …\nPlotting thread pool manager.\nA wrapper around thread pool pair for plotting purposes\nWrapper around <code>PlottingThreadPoolPair</code> that on <code>Drop</code> will …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet one of inner thread pool pairs, will wait until one is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new thread pool manager by instantiating …\nPlotting thread pool\nReplotting thread pool\nHow many thread pool pairs are being managed here\nAbstraction for CPU core set\nGet all cpu cores, grouped into sets according to NUMA …\nGet cpu core numbers in this set\nCreate thread pools manager.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse space-separated set of groups of CPU cores …\nPin current thread to this NUMA node (not just one CPU …\nThis function is supposed to be used with …\nRecommended number of thread pool size for farming, equal …\nModified version of SS58 parser extracted from Substrate …\nThread indices for each thread pool\nThis function is supposed to be used with …\nWill truncate list of CPU cores to this number.\nBase 58 requirement is violated\nLength is bad\nDisallowed SS58 Address Format for this datatype\nInvalid checksum\nInvalid SS58 prefix byte\nAn error type for SS58 decoding.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSome if the string is a properly encoded SS58Check address.")