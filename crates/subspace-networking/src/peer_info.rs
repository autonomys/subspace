mod handler;
mod protocol;

use crate::peer_info::handler::HandlerInEvent;
use event_listener_primitives::HandlerId;
use handler::Handler;
pub use handler::{Config, PeerInfoError, PeerInfoSuccess};
use libp2p::core::{Endpoint, Multiaddr};
use libp2p::swarm::behaviour::{ConnectionEstablished, FromSwarm};
use libp2p::swarm::{
    ConnectionClosed, ConnectionDenied, ConnectionId, NetworkBehaviour, NotifyHandler,
    PollParameters, THandler, THandlerInEvent, THandlerOutEvent, ToSwarm,
};
use libp2p::PeerId;
use parity_scale_codec::{Decode, Encode};
use std::collections::{HashSet, VecDeque};
use std::fmt;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::task::{Context, Poll, Waker};
use tracing::debug;

#[derive(Debug, Clone, Copy)]
/// Peer info notification marker.
pub struct Notification;
/// Defines a subscription to a peer-info notification.
pub type NotificationHandler = Arc<dyn Fn(&Notification) + Send + Sync + 'static>;

#[derive(Clone, Encode, Decode)]
/// Peer info data
pub struct PeerInfo {
    /// Peer role.
    pub role: PeerRole,
    // TODO: consider having a type-safe data structure bound to PeerRole
    /// Peer info data.
    pub data: Option<Vec<u8>>,
}

impl fmt::Debug for PeerInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let data_len = match &self.data {
            Some(data) => data.len(),
            None => 0,
        };

        f.debug_struct("PeerInfo")
            .field("role", &self.role)
            .field("data(bytes)", &data_len)
            .finish()
    }
}

impl Default for PeerInfo {
    fn default() -> Self {
        PeerInfo {
            role: PeerRole::Client,
            data: None,
        }
    }
}

#[derive(Clone, Debug, Encode, Decode)]
/// Defines the role of a peer
pub enum PeerRole {
    /// DSN farmer.
    Farmer,
    /// DSN node.
    Node,
    /// DSN bootstrap node.
    BootstrapNode,
    /// Unspecified client (testing, custom utilities, etc).
    Client,
}

/// A [`NetworkBehaviour`] that handles inbound peer info requests and
/// sends outbound peer info requests on the first established connection.
pub struct Behaviour<PeerInfoProvider> {
    /// Peer info protocol configuration.
    config: Config,
    /// Queue of events to yield to the swarm.
    events: VecDeque<Event>,
    /// Outbound peer info pushes.
    requests: Vec<Request>,
    /// Provides up-to-date peer info.
    peer_info_provider: PeerInfoProvider,
    /// Whether the behaviour should notify connected peers.
    should_notify_handlers: Arc<AtomicBool>,
    /// We just save the handler ID.
    _notify_handler_id: Option<HandlerId>,
    /// Known connected peers.
    connected_peers: HashSet<PeerId>,
    /// Future waker.
    waker: Option<Waker>,
}

#[derive(Debug)]
/// Peer info push request. Handlers wait for these requests to send data.
struct Request {
    peer_id: PeerId,
    peer_info: Arc<PeerInfo>,
}

/// Provides the current peer info data.
pub trait PeerInfoProvider: 'static {
    /// Returns the current peer info data.
    fn peer_info(&self) -> PeerInfo;
    /// Subscribe to peer info updates and invoke provided callback.
    fn on_notification(&self, callback: NotificationHandler) -> Option<HandlerId>;
}

/// Handles constant peer info data.
pub struct ConstantPeerInfoProvider {
    peer_info: PeerInfo,
}

impl ConstantPeerInfoProvider {
    /// Creates a new peer [`ConstantPeerInfoProvider`].
    pub fn new(peer_info: PeerInfo) -> Self {
        Self { peer_info }
    }
}

impl PeerInfoProvider for ConstantPeerInfoProvider {
    fn peer_info(&self) -> PeerInfo {
        self.peer_info.clone()
    }

    fn on_notification(&self, _: NotificationHandler) -> Option<HandlerId> {
        // No notifications.
        None
    }
}

/// Event generated by the `Peer Info` network behaviour.
#[derive(Debug)]
pub struct Event {
    /// The peer ID of the remote.
    pub peer_id: PeerId,
    /// The result of an inbound or outbound peer info request.
    pub result: Result<PeerInfoSuccess, PeerInfoError>,
}

impl<PIP: PeerInfoProvider> Behaviour<PIP> {
    /// Creates a new `Peer Info` network behaviour with the given configuration.
    pub fn new(config: Config, peer_info_provider: PIP) -> Self {
        let should_notify_handlers = Arc::new(AtomicBool::new(false));
        let notify_handler_id = peer_info_provider.on_notification({
            let should_notify_handlers = should_notify_handlers.clone();

            Arc::new(move |_| {
                should_notify_handlers.store(true, Ordering::SeqCst);
            })
        });

        Self {
            _notify_handler_id: notify_handler_id,
            config,
            peer_info_provider,
            events: VecDeque::new(),
            requests: Vec::new(),
            should_notify_handlers,
            connected_peers: HashSet::new(),
            waker: None,
        }
    }

    fn wake(&self) {
        if let Some(waker) = &self.waker {
            waker.wake_by_ref()
        }
    }
}

impl<PIP: PeerInfoProvider> NetworkBehaviour for Behaviour<PIP> {
    type ConnectionHandler = Handler;
    type OutEvent = Event;

    fn handle_established_inbound_connection(
        &mut self,
        _: ConnectionId,
        _: PeerId,
        _: &Multiaddr,
        _: &Multiaddr,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        Ok(Handler::new(self.config.clone()))
    }

    fn handle_established_outbound_connection(
        &mut self,
        _: ConnectionId,
        _: PeerId,
        _: &Multiaddr,
        _: Endpoint,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        Ok(Handler::new(self.config.clone()))
    }

    fn on_connection_handler_event(
        &mut self,
        peer: PeerId,
        _: ConnectionId,
        result: THandlerOutEvent<Self>,
    ) {
        self.events.push_front(Event {
            peer_id: peer,
            result,
        });
        self.wake();
    }

    fn poll(
        &mut self,
        cx: &mut Context<'_>,
        _: &mut impl PollParameters,
    ) -> Poll<ToSwarm<Self::OutEvent, THandlerInEvent<Self>>> {
        if self.should_notify_handlers.swap(false, Ordering::SeqCst) {
            debug!("Notify peer-info handlers.");

            self.requests.clear();
            let peer_info = Arc::new(self.peer_info_provider.peer_info());
            for peer_id in self.connected_peers.iter().cloned() {
                self.requests.push(Request {
                    peer_id,
                    peer_info: peer_info.clone(),
                });
            }
        }

        if let Some(e) = self.events.pop_back() {
            let Event { result, peer_id } = &e;

            match result {
                Ok(PeerInfoSuccess::Sent) => {
                    debug!(%peer_id, "Peer info sent.")
                }
                Ok(PeerInfoSuccess::Received(_)) => {
                    debug!(%peer_id, "Peer info received")
                }
                Err(err) => {
                    debug!(%peer_id, ?err, "Peer info error");
                }
            }

            return Poll::Ready(ToSwarm::GenerateEvent(e));
        }

        // Check for pending requests.
        if let Some(Request { peer_id, peer_info }) = self.requests.pop() {
            return Poll::Ready(ToSwarm::NotifyHandler {
                peer_id,
                handler: NotifyHandler::Any,
                event: HandlerInEvent { peer_info },
            });
        }

        self.waker = Some(cx.waker().clone());
        Poll::Pending
    }

    fn on_swarm_event(&mut self, event: FromSwarm<Self::ConnectionHandler>) {
        match event {
            FromSwarm::ConnectionEstablished(ConnectionEstablished {
                peer_id,
                other_established,
                ..
            }) => {
                self.connected_peers.insert(peer_id);

                // Push the peer-info request on the first connection.
                if other_established == 0 {
                    let peer_info = Arc::new(self.peer_info_provider.peer_info());
                    self.requests.push(Request { peer_id, peer_info });
                    self.wake();
                }
            }
            FromSwarm::ConnectionClosed(ConnectionClosed {
                peer_id,
                remaining_established,
                ..
            }) => {
                if remaining_established == 0 {
                    self.connected_peers.remove(&peer_id);
                }
            }
            FromSwarm::AddressChange(_)
            | FromSwarm::DialFailure(_)
            | FromSwarm::ListenFailure(_)
            | FromSwarm::NewListener(_)
            | FromSwarm::NewListenAddr(_)
            | FromSwarm::ExpiredListenAddr(_)
            | FromSwarm::ListenerError(_)
            | FromSwarm::ListenerClosed(_)
            | FromSwarm::NewExternalAddr(_)
            | FromSwarm::ExpiredExternalAddr(_) => {}
        }
    }
}
